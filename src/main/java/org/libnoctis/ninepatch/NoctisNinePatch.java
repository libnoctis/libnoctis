/*
 * Copyright 2015-2016 Adrien "Litarvan" Navratil & Victor "Wytrem"
 * This file is part of Libnoctis.
 * Libnoctis is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * Libnoctis is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 * You should have received a copy of the GNU Lesser General Public License
 * along with Libnoctis. If not, see <http://www.gnu.org/licenses/>.
 */
package org.libnoctis.ninepatch;


import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;

import org.libnoctis.render.gl.GlTexture;
import org.libnoctis.util.Vector2i;


/**
 * The Noctis Nine Patch
 * The Noctis version of the Nine Patch, generated by
 * the {@link NinePatch} class.
 *
 * @author Litarvan
 * @version 1.0.0
 * @since 1.0.0
 */
public class NoctisNinePatch
{
    /**
     * The nine patch image (the real one, without the black pixels)
     */
    private BufferedImage image;

    /**
     * This nine patch chunk
     */
    private NoctisNinePatchChunk chunk;

    /**
     * The Noctis nine patch
     *
     * @param image The image of the patch (the real one, without the black
     *        pixels)
     * @param chunk The patch chunk
     */
    public NoctisNinePatch(BufferedImage image, NoctisNinePatchChunk chunk)
    {
        this.image = image;
        this.chunk = chunk;
    }

    /**
     * Generate a texture from this nine patch with the given
     * dimensions
     *
     * @param width The width of the texture to generate
     * @param height The height of the texture to generate
     * @return The generated Texture
     */
    public GlTexture generateFor(int width, int height)
    {
        return generateFor(new Vector2i(width, height));
    }

    /**
     * Generate a texture from this nine patch with the given
     * dimensions
     *
     * @param dimensions The dimensions of the texture to generate
     * @return The generated Texture
     */
    public GlTexture generateFor(Vector2i dimensions)
    {
        BufferedImage generated = CompatibleImageMaker.translucent(dimensions);
        Graphics2D g = (Graphics2D) generated.getGraphics();

        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);

        if (this.chunk.getPatches().isEmpty())
            return new GlTexture(this.image);

        DrawingData data = computePatches(dimensions);

        int x = 0;
        int y = 0;

        int fixedIndex = 0;
        int horizontalIndex = 0;
        int verticalIndex = 0;
        int patchIndex = 0;

        boolean hStretch;
        boolean vStretch;

        float vWeightSum = 1.0f;
        float vRemainder = data.getVerticalRemainder();

        vStretch = this.getChunk().isVerticalStartsWithPatch();
        while (y < dimensions.getY() - 1)
        {
            hStretch = this.getChunk().isHorizontalStartsWithPatch();

            int height = 0;
            float vExtra = 0.0f;

            float hWeightSum = 1.0f;
            float hRemainder = data.getHorizontalRemainder();

            while (x < dimensions.getX() - 1)
            {
                Rectangle r;

                if (!vStretch)
                {
                    if (hStretch)
                    {
                        r = this.getChunk().getHorizontalPatches().get(horizontalIndex++);

                        float extra = r.width / data.getHorizontalPatchesSum();
                        int width = (int) (extra * hRemainder / hWeightSum);

                        hWeightSum -= extra;
                        hRemainder -= width;

                        g.drawImage(image, x, y, x + width, y + r.height, r.x, r.y, r.x + r.width, r.y + r.height, null);

                        x += width;
                    }
                    else
                    {
                        r = this.getChunk().getFixed().get(fixedIndex++);

                        g.drawImage(image, x, y, x + r.width, y + r.height, r.x, r.y, r.x + r.width, r.y + r.height, null);

                        x += r.width;
                    }

                    height = r.height;
                }
                else
                {
                    if (hStretch)
                    {
                        r = this.getChunk().getPatches().get(patchIndex++);
                        vExtra = r.height / data.getVerticalPatchesSum();
                        height = (int) (vExtra * vRemainder / vWeightSum);

                        float extra = r.width / data.getHorizontalPatchesSum();
                        int width = (int) (extra * hRemainder / hWeightSum);

                        hWeightSum -= extra;
                        hRemainder -= width;

                        g.drawImage(image, x, y, x + width, y + height, r.x, r.y, r.x + r.width, r.y + r.height, null);

                        x += width;
                    }
                    else
                    {
                        r = this.getChunk().getVerticalPatches().get(verticalIndex++);
                        vExtra = r.height / data.getVerticalPatchesSum();
                        height = (int) (vExtra * vRemainder / vWeightSum);

                        g.drawImage(image, x, y, x + r.width, y + height, r.x, r.y, r.x + r.width, r.y + r.height, null);

                        x += r.width;
                    }

                }

                hStretch = !hStretch;
            }

            x = 0;
            y += height;

            if (vStretch)
            {
                vWeightSum -= vExtra;
                vRemainder -= height;
            }

            vStretch = !vStretch;
        }

        g.dispose();

        return new GlTexture(generated);
    }

    private DrawingData computePatches(Vector2i dimensions)
    {
        DrawingData data = new DrawingData();

        boolean measuredWidth = false;
        boolean endRow = true;

        int remainderHorizontal = 0;
        int remainderVertical = 0;

        if (this.getChunk().getFixed().size() > 0)
        {
            int start = this.getChunk().getFixed().get(0).y;

            for (Rectangle rect : this.getChunk().getFixed())
            {
                if (rect.y > start)
                    endRow = measuredWidth = true;

                if (!measuredWidth)
                    remainderHorizontal += rect.width;

                if (endRow)
                {
                    remainderVertical += rect.height;
                    endRow = false;
                    start = rect.y;
                }
            }
        }

        data.setHorizontalPatchesSum(dimensions.getX() - remainderHorizontal);
        data.setVerticalRemainder(dimensions.getY() - remainderVertical);

        data.setHorizontalPatchesSum(0);

        int start = -1;

        for (Rectangle rect : this.getChunk().getHorizontalPatches().isEmpty() ? this.getChunk().getPatches() : this.getChunk().getHorizontalPatches())
            if (rect.x > start)
            {
                data.setHorizontalPatchesSum(data.getHorizontalPatchesSum() + rect.width);
                start = rect.x;
            }

        data.setVerticalPatchesSum(0);

        start = -1;

        for (Rectangle rect : this.getChunk().getVerticalPatches().isEmpty() ? this.getChunk().getPatches() : this.getChunk().getVerticalPatches())
        {
            if (rect.y > start)
            {
                data.setVerticalPatchesSum(data.getVerticalPatchesSum() + rect.height);
                start = rect.y;
            }
        }

        return data;
    }

    /**
     * @return This nine patch image (the real one, without the black pixels)
     */
    public BufferedImage getImage()
    {
        return image;
    }

    /**
     * @return This nine patch chunk
     */
    public NoctisNinePatchChunk getChunk()
    {
        return chunk;
    }
}
